[uy.klutter.vertx](../index.md) / [io.vertx.core.Vertx](.)


### Extensions for io.vertx.core.Vertx

|&nbsp;|&nbsp;|
|---|---|
| [deployVerticle](deploy-verticle.md) | <code>fun <T : AbstractVerticle> Vertx.deployVerticle(verticleClass: KClass<T>): Unit</code><br/><code>fun <T : AbstractVerticle> Vertx.deployVerticle(verticleClass: [Class](http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html)<T>): Unit</code><br/>Deploy a verticle async without waiting for it to complete or tracking it in any way |
| [executeBlocking](execute-blocking.md) | <code>fun <T : Any> Vertx.executeBlocking(blockingCode: () -> T): Promise<T, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/>Execute blocking code using vert.x dispatcher returning a `Promise&lt;T,Exception&gt;`.  Since Kovenant and<br/>vert.x dispatching are united, this is the same as doing `task{...}` in Kovenant except that no<br/>vert.x context will be in thread local storage if you do not use this method. |
| [promiseClose](promise-close.md) | <code>fun Vertx.promiseClose(): Promise<Unit, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/>Close vert.x |
| [promiseDeployVerticle](promise-deploy-verticle.md) | <code>fun Vertx.promiseDeployVerticle(verticle: Verticle): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/><code>fun Vertx.promiseDeployVerticle(verticle: Verticle, options: DeploymentOptions): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/><code>fun <T : AbstractVerticle> Vertx.promiseDeployVerticle(verticleClass: KClass<T>): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/><code>fun <T : AbstractVerticle> Vertx.promiseDeployVerticle(verticleClass: KClass<T>, options: DeploymentOptions): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/><code>fun <T : AbstractVerticle> Vertx.promiseDeployVerticle(verticleClass: [Class](http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html)<T>): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/><code>fun <T : AbstractVerticle> Vertx.promiseDeployVerticle(verticleClass: [Class](http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html)<T>, options: DeploymentOptions): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/><code>fun Vertx.promiseDeployVerticle(name: String): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/><code>fun Vertx.promiseDeployVerticle(name: String, options: DeploymentOptions): Promise<String, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/>Deploy a verticle |
| [promiseExecuteBlocking](promise-execute-blocking.md) | <code>fun <T : Any> Vertx.promiseExecuteBlocking(blockingCode: () -> T): Promise<T, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/>Execute blocking code using vert.x dispatcher returning a `Promise&lt;T,Exception&gt;`.  Since Kovenant and<br/>vert.x dispatching are united, this is the same as doing `task{...}` in Kovenant except that no<br/>vert.x context will be in thread local storage if you do not use this method. |
| [promiseReply](promise-reply.md) | <code>fun <T : Any> Vertx.promiseReply(address: String, message: Any): Promise<T, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/>Sends the message and returns a promise of a reply to that message. |
| [promiseUndeploy](promise-undeploy.md) | <code>fun Vertx.promiseUndeploy(deploymentId: String): Promise<Unit, [Exception](http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html)></code><br/>Undeploy a verticle |
